
```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {

        /**
         * @brief 利用哈希表，在表中找寻taget减去nums[i]的差值，并且同步保留nums[i]到哈希表中，first代表值，second代表序号
         *         时间复杂度O(N),因为只遍历一次
         *         空间复杂度O(N), 取决于一维数组的长度
        */

        unordered_map<int,int> m_map;

        for(int i =0;i<nums.size();i++)
        {
            auto it = m_map.find(target - nums[i]);
            if(it != m_map.end())
            {
                return {it->second,i};
            }

            m_map[nums[i]] = i;

        }

        return {};

        /**
         * @brief 暴力解决，如果两遍for循环找不到的话就直接返回空的数组
         *         时间复杂度O(N^2),因为遍历2次
         *         空间复杂度O(1)
         */       

        // if(nums.empty()) return nums;  //这里不太有必要
 
        // for(int i = 0;i<nums.size();i++)
        // {
        //     for(int j =i+1;j<nums.size();j++)
        //     {
        //         if(nums[i]+nums[j] == target)
        //         {
        //             return {i,j};
        //         }
        //     }
        // }

        // return {};
        
    }
};
```
